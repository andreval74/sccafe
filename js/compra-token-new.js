/**
 * üõí COMPRA DE TOKENS DIN√ÇMICA - M√ìDULO ESPEC√çFICO
 * 
 * üìç RESPONSABILIDADES:
 * - Interface din√¢mica para compra de tokens via MetaMask
 * - Verifica√ß√£o de conex√£o e habilita√ß√£o de campos
 * - Leitura din√¢mica de contratos da blockchain
 * - Verifica√ß√£o de compatibilidade para compra direta
 * - C√°lculo din√¢mico de pre√ßos e execu√ß√£o de transa√ß√µes
 * 
 * üîó DEPEND√äNCIAS:
 * - ethers.js v5.7.2
 * - MetaMaskConnector (shared/metamask-connector.js) - REUTILIZADO
 * - CommonUtils (shared/common-utils.js) - REUTILIZADO
 * - TokenGlobal (shared/token-global.js) - REUTILIZADO
 * 
 * üì§ EXPORTS:
 * - DynamicTokenPurchase: Classe principal
 * - Fun√ß√µes utilit√°rias espec√≠ficas de compra din√¢mica
 */

// ==================== CONFIGURA√á√ïES ====================

const CONFIG = {
    // Configura√ß√µes din√¢micas (sem contrato fixo)
    defaultTokenPrice: "0.001", // BNB por token (padr√£o)
    supportedChains: [56, 97], // BSC Mainnet e Testnet
    
    // ABI estendido para verifica√ß√£o completa
    tokenABI: [
        // Fun√ß√µes b√°sicas ERC-20
        "function balanceOf(address owner) view returns (uint256)",
        "function totalSupply() view returns (uint256)",
        "function name() view returns (string)",
        "function symbol() view returns (string)",
        "function decimals() view returns (uint8)",
        "function transfer(address to, uint256 amount) returns (bool)",
        
        // Fun√ß√µes para verificar compra direta
        "function buy() payable",
        "function buyTokens() payable",
        "function purchase() payable",
        "function tokenPrice() view returns (uint256)",
        "function price() view returns (uint256)",
        "function getPrice() view returns (uint256)"
    ],
    
    // Configura√ß√µes de gas
    gasLimit: 200000,
    gasPrice: "5000000000" // 5 gwei
};

// ==================== ESTADO GLOBAL ====================

let currentProvider = null;
let currentSigner = null;
let walletConnected = false;
let walletAddress = '';
let networkData = {};
let currentContract = null;
let tokenInfo = {};
let buyFunctionName = null;

// ==================== INICIALIZA√á√ÉO ====================

/**
 * Inicializa√ß√£o principal
 */
document.addEventListener('DOMContentLoaded', function() {
    console.log('üõí Sistema de Compra Din√¢mica iniciado');
    
    initializeWalletConnection();
    setupEventListeners();
    checkInitialWalletState();
});

/**
 * Verifica estado inicial da wallet (sem tentar conectar)
 */
async function checkInitialWalletState() {
    if (typeof window.ethereum !== 'undefined') {
        try {
            // Apenas verifica se j√° est√° conectado, sem solicitar
            const accounts = await window.ethereum.request({
                method: 'eth_accounts'
            });
            
            if (accounts.length > 0) {
                walletAddress = accounts[0];
                walletConnected = true;
                await detectNetwork();
                updateWalletUI();
                enableContractSection();
            }
        } catch (error) {
            console.log('Wallet n√£o conectada previamente');
        }
    }
}

/**
 * Configura event listeners
 */
function setupEventListeners() {
    // Conex√£o MetaMask
    const connectBtn = document.getElementById('connect-metamask-btn');
    if (connectBtn) {
        connectBtn.addEventListener('click', connectWallet);
    }
    
    // Verifica√ß√£o de contrato
    const verifyBtn = document.getElementById('verify-contract-btn');
    if (verifyBtn) {
        verifyBtn.addEventListener('click', verifyContract);
    }
    
    // Campo de endere√ßo do contrato
    const contractInput = document.getElementById('contract-address');
    if (contractInput) {
        contractInput.addEventListener('input', validateContractAddress);
    }
    
    // Campos de compra
    const quantityInput = document.getElementById('token-quantity');
    const priceInput = document.getElementById('token-price');
    
    if (quantityInput) {
        quantityInput.addEventListener('input', calculateTotal);
    }
    
    if (priceInput) {
        priceInput.addEventListener('input', calculateTotal);
    }
    
    // Bot√£o de compra
    const purchaseBtn = document.getElementById('execute-purchase-btn');
    if (purchaseBtn) {
        purchaseBtn.addEventListener('click', executePurchase);
    }
}

// ==================== GERENCIAMENTO DE WALLET ====================

/**
 * Conecta com a MetaMask
 */
async function connectWallet() {
    try {
        if (typeof window.ethereum === 'undefined') {
            alert('MetaMask n√£o detectado! Por favor, instale a MetaMask.');
            return;
        }
        
        console.log('üîó Conectando com MetaMask...');
        
        // Solicita conex√£o
        const accounts = await window.ethereum.request({
            method: 'eth_requestAccounts'
        });
        
        if (accounts.length > 0) {
            walletAddress = accounts[0];
            walletConnected = true;
            
            // Atualiza UI
            await detectNetwork();
            updateWalletUI();
            enableContractSection();
            
            console.log('‚úÖ Wallet conectada:', walletAddress);
        }
        
    } catch (error) {
        console.error('‚ùå Erro ao conectar wallet:', error);
        alert('Erro ao conectar com a MetaMask: ' + error.message);
    }
}

/**
 * Atualiza interface da wallet
 */
function updateWalletUI() {
    const statusInput = document.getElementById('wallet-status');
    const connectBtn = document.getElementById('connect-metamask-btn');
    const networkSection = document.getElementById('network-info-section');
    
    if (walletConnected && walletAddress) {
        // Status da wallet
        if (statusInput) {
            statusInput.value = `${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}`;
            statusInput.classList.add('text-success');
        }
        
        // Bot√£o conectar
        if (connectBtn) {
            connectBtn.innerHTML = '<i class="bi bi-check-circle"></i> CONECTADO';
            connectBtn.classList.remove('btn-warning');
            connectBtn.classList.add('btn-success');
            connectBtn.disabled = true;
        }
        
        // Mostra info da rede
        if (networkSection) {
            networkSection.style.display = 'block';
        }
    }
}

/**
 * Detecta a rede atual
 */
async function detectNetwork() {
    try {
        const chainId = await window.ethereum.request({
            method: 'eth_chainId'
        });
        
        networkData = getNetworkInfo(chainId);
        
        // Atualiza UI da rede
        const currentNetworkSpan = document.getElementById('current-network');
        const chainIdSpan = document.getElementById('chain-id-value');
        
        if (currentNetworkSpan) {
            currentNetworkSpan.textContent = networkData.name;
        }
        
        if (chainIdSpan) {
            chainIdSpan.textContent = networkData.chainId;
        }
        
        console.log('üåê Rede detectada:', networkData);
        
    } catch (error) {
        console.error('‚ùå Erro ao detectar rede:', error);
    }
}

/**
 * Obt√©m informa√ß√µes da rede baseado no chainId
 */
function getNetworkInfo(chainId) {
    const networks = {
        '0x38': { name: 'BSC Mainnet', chainId: '56' },
        '0x61': { name: 'BSC Testnet', chainId: '97' },
        '0x1': { name: 'Ethereum Mainnet', chainId: '1' },
        '0x89': { name: 'Polygon Mainnet', chainId: '137' },
        '0xaa36a7': { name: 'Sepolia Testnet', chainId: '11155111' }
    };
    
    return networks[chainId] || { 
        name: 'Rede Desconhecida', 
        chainId: parseInt(chainId, 16).toString() 
    };
}

// ==================== GERENCIAMENTO DE CONTRATO ====================

/**
 * Habilita se√ß√£o de contrato ap√≥s conex√£o
 */
function enableContractSection() {
    const contractInput = document.getElementById('contract-address');
    const verifyBtn = document.getElementById('verify-contract-btn');
    
    if (contractInput) {
        contractInput.disabled = false;
        contractInput.placeholder = "0x1234567890123456789012345678901234567890";
    }
    
    if (verifyBtn) {
        verifyBtn.disabled = false;
    }
}

/**
 * Valida endere√ßo do contrato
 */
function validateContractAddress() {
    const contractInput = document.getElementById('contract-address');
    const verifyBtn = document.getElementById('verify-contract-btn');
    
    if (contractInput && verifyBtn) {
        const address = contractInput.value.trim();
        
        // Verifica se √© um endere√ßo v√°lido (42 caracteres, come√ßando com 0x)
        const isValid = address.length === 42 && address.startsWith('0x');
        
        if (isValid) {
            contractInput.classList.remove('is-invalid');
            contractInput.classList.add('is-valid');
            verifyBtn.disabled = false;
        } else {
            contractInput.classList.remove('is-valid');
            if (address.length > 0) {
                contractInput.classList.add('is-invalid');
            }
            verifyBtn.disabled = true;
        }
    }
}

/**
 * Verifica o contrato na blockchain
 */
async function verifyContract() {
    const contractInput = document.getElementById('contract-address');
    const contractAddress = contractInput.value.trim();
    
    if (!contractAddress) {
        alert('Por favor, digite o endere√ßo do contrato');
        return;
    }
    
    try {
        // Mostra loading
        updateVerifyButton(true);
        clearContractMessages();
        hideTokenInfo();
        
        addContractMessage('üîç Verificando contrato na blockchain...', 'info');
        
        // Inicializa provider
        currentProvider = new ethers.providers.Web3Provider(window.ethereum);
        currentSigner = currentProvider.getSigner();
        
        // Verifica se o endere√ßo tem c√≥digo (√© um contrato)
        const code = await currentProvider.getCode(contractAddress);
        if (code === '0x') {
            throw new Error('Endere√ßo n√£o √© um smart contract v√°lido');
        }
        
        addContractMessage('‚úÖ Smart contract detectado', 'success');
        
        // Tenta criar inst√¢ncia do contrato
        currentContract = new ethers.Contract(contractAddress, CONFIG.tokenABI, currentProvider);
        
        // Verifica fun√ß√µes b√°sicas ERC-20
        await verifyERC20Functions();
        
        // Verifica fun√ß√µes de compra
        await verifyBuyFunctions();
        
        // Mostra informa√ß√µes do token
        await loadTokenInfo();
        showTokenInfo();
        
        addContractMessage('üéâ Contrato verificado com sucesso!', 'success');
        
    } catch (error) {
        console.error('‚ùå Erro ao verificar contrato:', error);
        addContractMessage(`‚ùå Erro: ${error.message}`, 'error');
    } finally {
        updateVerifyButton(false);
    }
}

/**
 * Verifica fun√ß√µes b√°sicas ERC-20
 */
async function verifyERC20Functions() {
    try {
        // Testa fun√ß√µes b√°sicas
        await currentContract.name();
        await currentContract.symbol();
        await currentContract.decimals();
        await currentContract.totalSupply();
        
        updateCompatibilityStatus('erc20Status', '‚úÖ Compat√≠vel', 'success');
        updateCompatibilityStatus('transferStatus', '‚úÖ Detectada', 'success');
        addContractMessage('‚úÖ Fun√ß√µes ERC-20 b√°sicas detectadas', 'success');
        
    } catch (error) {
        updateCompatibilityStatus('erc20Status', '‚ùå Incompat√≠vel', 'error');
        updateCompatibilityStatus('transferStatus', '‚ùå N√£o detectada', 'error');
        throw new Error('Contrato n√£o √© ERC-20 compat√≠vel');
    }
}

/**
 * Verifica fun√ß√µes de compra dispon√≠veis
 */
async function verifyBuyFunctions() {
    const buyFunctions = ['buy', 'buyTokens', 'purchase'];
    
    for (const funcName of buyFunctions) {
        try {
            // Verifica se a fun√ß√£o existe tentando fazer um call est√°tico
            const func = currentContract[funcName];
            if (func) {
                buyFunctionName = funcName;
                updateCompatibilityStatus('buyStatus', '‚úÖ Dispon√≠vel', 'success');
                addContractMessage(`‚úÖ Fun√ß√£o de compra "${funcName}" detectada`, 'success');
                return;
            }
        } catch (error) {
            // Fun√ß√£o n√£o existe, continua testando
        }
    }
    
    // Nenhuma fun√ß√£o de compra encontrada
    updateCompatibilityStatus('buyStatus', '‚ùå N√£o dispon√≠vel', 'warning');
    addContractMessage('‚ö†Ô∏è Fun√ß√£o de compra direta n√£o detectada', 'warning');
    buyFunctionName = null;
}

/**
 * Carrega informa√ß√µes do token
 */
async function loadTokenInfo() {
    try {
        tokenInfo = {
            name: await currentContract.name(),
            symbol: await currentContract.symbol(),
            decimals: await currentContract.decimals(),
            totalSupply: await currentContract.totalSupply(),
            contractBalance: await currentProvider.getBalance(currentContract.address)
        };
        
        // Tenta detectar pre√ßo
        try {
            let price = null;
            const priceFunctions = ['tokenPrice', 'price', 'getPrice'];
            
            for (const priceFunc of priceFunctions) {
                try {
                    price = await currentContract[priceFunc]();
                    break;
                } catch (e) {
                    // Fun√ß√£o n√£o existe, tenta pr√≥xima
                }
            }
            
            if (price) {
                tokenInfo.price = ethers.utils.formatEther(price);
            } else {
                tokenInfo.price = CONFIG.defaultTokenPrice;
            }
        } catch (error) {
            tokenInfo.price = CONFIG.defaultTokenPrice;
        }
        
        updateTokenInfoUI();
        enablePurchaseSection();
        
    } catch (error) {
        throw new Error(`Erro ao carregar informa√ß√µes do token: ${error.message}`);
    }
}

/**
 * Atualiza UI com informa√ß√µes do token
 */
function updateTokenInfoUI() {
    document.getElementById('tokenName').textContent = tokenInfo.name || '-';
    document.getElementById('tokenSymbol').textContent = tokenInfo.symbol || '-';
    document.getElementById('tokenDecimals').textContent = tokenInfo.decimals || '-';
    
    // Formata total supply
    const totalSupply = ethers.utils.formatUnits(tokenInfo.totalSupply, tokenInfo.decimals);
    document.getElementById('tokenTotalSupply').textContent = `${formatNumber(totalSupply)} ${tokenInfo.symbol}`;
    
    // Formata saldo do contrato
    const contractBalance = ethers.utils.formatEther(tokenInfo.contractBalance);
    document.getElementById('contractBalance').textContent = `${formatNumber(contractBalance)} BNB`;
    
    // Define pre√ßo
    const priceInput = document.getElementById('token-price');
    if (priceInput) {
        priceInput.value = tokenInfo.price;
    }
}

// ==================== GERENCIAMENTO DE COMPRA ====================

/**
 * Habilita se√ß√£o de compra
 */
function enablePurchaseSection() {
    const section = document.getElementById('purchase-section');
    const priceInput = document.getElementById('token-price');
    const quantityInput = document.getElementById('token-quantity');
    const purchaseBtn = document.getElementById('execute-purchase-btn');
    
    if (section) section.style.display = 'block';
    if (priceInput) priceInput.disabled = false;
    if (quantityInput) quantityInput.disabled = false;
    if (purchaseBtn && buyFunctionName) purchaseBtn.disabled = false;
}

/**
 * Calcula total da compra
 */
function calculateTotal() {
    const priceInput = document.getElementById('token-price');
    const quantityInput = document.getElementById('token-quantity');
    const totalTokensSpan = document.getElementById('totalTokens');
    const totalPriceSpan = document.getElementById('totalPrice');
    
    if (priceInput && quantityInput && totalTokensSpan && totalPriceSpan) {
        const price = parseFloat(priceInput.value) || 0;
        const quantity = parseFloat(quantityInput.value) || 0;
        const total = price * quantity;
        
        totalTokensSpan.textContent = formatNumber(quantity);
        totalPriceSpan.textContent = `${formatNumber(total)} BNB`;
    }
}

/**
 * Executa a compra de tokens
 */
async function executePurchase() {
    if (!buyFunctionName) {
        alert('Este contrato n√£o suporta compra direta');
        return;
    }
    
    const quantityInput = document.getElementById('token-quantity');
    const priceInput = document.getElementById('token-price');
    
    const quantity = parseFloat(quantityInput.value);
    const price = parseFloat(priceInput.value);
    
    if (!quantity || quantity <= 0) {
        alert('Por favor, digite uma quantidade v√°lida');
        return;
    }
    
    if (!price || price <= 0) {
        alert('Por favor, digite um pre√ßo v√°lido');
        return;
    }
    
    try {
        const totalValue = (price * quantity).toString();
        const valueInWei = ethers.utils.parseEther(totalValue);
        
        clearPurchaseMessages();
        addPurchaseMessage('üöÄ Iniciando transa√ß√£o de compra...', 'info');
        
        // Executa a transa√ß√£o
        const contract = currentContract.connect(currentSigner);
        const tx = await contract[buyFunctionName]({
            value: valueInWei,
            gasLimit: CONFIG.gasLimit
        });
        
        addPurchaseMessage(`‚úÖ Transa√ß√£o enviada: ${tx.hash}`, 'success');
        addPurchaseMessage('‚è≥ Aguardando confirma√ß√£o...', 'info');
        
        // Aguarda confirma√ß√£o
        const receipt = await tx.wait();
        
        addPurchaseMessage('üéâ Transa√ß√£o confirmada!', 'success');
        
        // Mostra detalhes da transa√ß√£o
        showTransactionDetails(receipt, quantity, totalValue);
        
    } catch (error) {
        console.error('‚ùå Erro na compra:', error);
        addPurchaseMessage(`‚ùå Erro: ${error.message}`, 'error');
    }
}

// ==================== FUN√á√ïES AUXILIARES ====================

/**
 * Atualiza status de compatibilidade
 */
function updateCompatibilityStatus(elementId, text, type) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = text;
        element.className = `fw-bold mb-1 text-${type === 'success' ? 'success' : type === 'error' ? 'danger' : 'warning'}`;
    }
}

/**
 * Atualiza bot√£o de verifica√ß√£o
 */
function updateVerifyButton(isLoading) {
    const btn = document.getElementById('verify-contract-btn');
    if (btn) {
        if (isLoading) {
            btn.innerHTML = '<i class="bi bi-arrow-clockwise spin me-2"></i>VERIFICANDO...';
            btn.disabled = true;
        } else {
            btn.innerHTML = '<i class="bi bi-search me-2"></i>VERIFICAR';
            btn.disabled = false;
        }
    }
}

/**
 * Mostra se√ß√£o de informa√ß√µes do token
 */
function showTokenInfo() {
    const section = document.getElementById('token-info-section');
    if (section) {
        section.style.display = 'block';
    }
}

/**
 * Esconde se√ß√£o de informa√ß√µes do token
 */
function hideTokenInfo() {
    const section = document.getElementById('token-info-section');
    if (section) {
        section.style.display = 'none';
    }
}

/**
 * Mostra detalhes da transa√ß√£o
 */
function showTransactionDetails(receipt, tokensQuantity, totalValue) {
    const section = document.getElementById('transactionDetails');
    if (section) {
        section.style.display = 'block';
        
        // Preenche os dados
        document.getElementById('txHash').textContent = receipt.transactionHash;
        document.getElementById('txTokensReceived').textContent = `${formatNumber(tokensQuantity)} ${tokenInfo.symbol}`;
        document.getElementById('txValue').textContent = `${formatNumber(totalValue)} BNB`;
        
        // Calcula gas usado
        const gasUsed = receipt.gasUsed;
        const gasPrice = receipt.effectiveGasPrice || ethers.utils.parseUnits('5', 'gwei');
        const gasCost = ethers.utils.formatEther(gasUsed.mul(gasPrice));
        document.getElementById('txGasPrice').textContent = `${formatNumber(gasCost)} BNB`;
        
        // Total pago
        const totalCost = parseFloat(totalValue) + parseFloat(gasCost);
        document.getElementById('txTotalCost').textContent = `${formatNumber(totalCost)} BNB`;
    }
}

/**
 * Formata n√∫meros para exibi√ß√£o
 */
function formatNumber(num) {
    const number = parseFloat(num);
    if (isNaN(number)) return '0';
    
    if (number >= 1000000) {
        return (number / 1000000).toFixed(2) + 'M';
    } else if (number >= 1000) {
        return (number / 1000).toFixed(2) + 'K';
    } else if (number < 0.001 && number > 0) {
        return number.toExponential(3);
    } else {
        return number.toLocaleString('pt-BR', { maximumFractionDigits: 6 });
    }
}

// ==================== SISTEMA DE FEEDBACK ====================

/**
 * Adiciona mensagem na se√ß√£o de contrato
 */
function addContractMessage(msg, type = 'info') {
    const listId = "contractErrors";
    const containerId = "contractResult";
    
    const container = document.getElementById(containerId);
    const list = document.getElementById(listId);
    
    if (container && list) {
        const li = document.createElement('li');
        li.innerHTML = msg;
        li.className = getMessageClass(type);
        list.appendChild(li);
        container.style.display = 'block';
        
        // Auto-scroll
        container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

/**
 * Adiciona mensagem na se√ß√£o de compra
 */
function addPurchaseMessage(msg, type = 'info') {
    const listId = "purchaseErrors";
    const containerId = "purchaseResult";
    
    const container = document.getElementById(containerId);
    const list = document.getElementById(listId);
    
    if (container && list) {
        const li = document.createElement('li');
        li.innerHTML = msg;
        li.className = getMessageClass(type);
        list.appendChild(li);
        container.style.display = 'block';
        
        // Auto-scroll
        container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

/**
 * Limpa mensagens da se√ß√£o de contrato
 */
function clearContractMessages() {
    const list = document.getElementById("contractErrors");
    const container = document.getElementById("contractResult");
    
    if (list) list.innerHTML = '';
    if (container) container.style.display = 'none';
}

/**
 * Limpa mensagens da se√ß√£o de compra
 */
function clearPurchaseMessages() {
    const list = document.getElementById("purchaseErrors");
    const container = document.getElementById("purchaseResult");
    
    if (list) list.innerHTML = '';
    if (container) container.style.display = 'none';
}

/**
 * Retorna classe CSS baseada no tipo de mensagem
 */
function getMessageClass(type) {
    const classes = {
        'info': 'text-info',
        'success': 'text-success', 
        'warning': 'text-warning',
        'error': 'text-danger'
    };
    return classes[type] || 'text-info';
}

// ==================== FUN√á√ïES GLOBAIS PARA COMPATIBILIDADE ====================

/**
 * Inicializa conex√£o da wallet (compatibilidade)
 */
function initializeWalletConnection() {
    // Monitora mudan√ßas de rede e conta
    if (typeof window.ethereum !== 'undefined') {
        window.ethereum.on('accountsChanged', (accounts) => {
            if (accounts.length > 0) {
                walletAddress = accounts[0];
                walletConnected = true;
                updateWalletUI();
                enableContractSection();
            } else {
                walletConnected = false;
                walletAddress = '';
                // Reset da interface
                location.reload();
            }
        });
        
        window.ethereum.on('chainChanged', () => {
            // Recarrega a p√°gina quando muda de rede
            location.reload();
        });
    }
}

// ==================== EXPORTS ====================

// Tornar fun√ß√µes dispon√≠veis globalmente para compatibilidade
window.DynamicTokenPurchase = {
    connectWallet,
    verifyContract,
    executePurchase,
    calculateTotal,
    addContractMessage,
    addPurchaseMessage,
    clearContractMessages,
    clearPurchaseMessages
};

// CSS para anima√ß√£o de loading
const style = document.createElement('style');
style.textContent = `
    .spin {
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
`;
document.head.appendChild(style);
