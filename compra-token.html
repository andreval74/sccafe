<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Compra Direta TKN</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
</head>
<body>
<h2>Compra Direta de TKN</h2>

<button id="checkContract">Verificar Contrato</button>
<label>Quantidade de Tokens:</label>
<input type="number" id="tokenAmount" placeholder="Quantidade de tokens" min="1">
<button id="buyButton">Comprar</button>

<p id="status"></p>
<ul id="errorList" style="color:red;"></ul>

<script>
const contractAddress = "0x5265F80e30e019344a218Dd89b67cBE164511c65"; // Endereço do TKN na testnet
const tokenDecimals = 18; // Decimais do token
const tokenPrice = ethers.utils.parseEther("0.003"); // Preço inicial em tBNB por token

let provider;
let signer;

async function connectWallet() {
    if (window.ethereum) {
        try {
            provider = new ethers.providers.Web3Provider(window.ethereum);
            await provider.send("eth_requestAccounts", []);
            signer = provider.getSigner();
            document.getElementById("status").innerText = "Carteira conectada: " + await signer.getAddress();
        } catch (err) {
            addError("Erro ao conectar carteira: " + err.message);
            throw err;
        }
    } else {
        alert("Instale a Metamask ou outro provedor Web3!");
    }
}

async function buyTokens() {
    clearErrors();
    const amountInput = document.getElementById("tokenAmount").value;
    if (!amountInput || amountInput <= 0) {
        addError("Informe a quantidade de tokens.");
        return;
    }

    if (!signer) {
        addError("Carteira não conectada.");
        return;
    }

    let amountBNB, amountWei;
    try {
        amountBNB = tokenPrice.mul(ethers.BigNumber.from(amountInput)); // total a pagar
        amountWei = amountBNB; // já está em wei
    } catch (err) {
        addError("Erro ao calcular valor em BNB: " + err.message);
        return;
    }

    // Verificar saldo antes de enviar
    try {
        const balance = await signer.getBalance();
        
        if (balance.lt(amountWei)) {
            addError("Saldo insuficiente para a transação.");
            return;
        }
    } catch (err) {
        addError("Erro ao verificar saldo: " + err.message);
        return;
    }

    // Verificar rede
    try {
        const network = await provider.getNetwork();
        
        if (network.chainId !== 97) { // BSC Testnet
            addError("Por favor, conecte-se à BSC Testnet (chainId: 97)");
            return;
        }
    } catch (err) {
        addError("Erro ao verificar rede: " + err.message);
        return;
    }

    try {
        document.getElementById("status").innerText = "Enviando transação...";
        
        const tx = await signer.sendTransaction({
            to: contractAddress,
            value: amountWei
        });
        
        document.getElementById("status").innerText = "Transação enviada. Aguarde confirmação...";
        await tx.wait();
        document.getElementById("status").innerText = `Compra concluída! Você comprou ${amountInput} tokens. Tx: ${tx.hash}`;
    } catch (err) {
        addError("Erro na transação: " + err.message);
        if (err.reason) {
            addError("Motivo: " + err.reason);
        }
    }
}

async function checkContract() {
    clearErrors();
    
    if (!provider) {
        try {
            provider = new ethers.providers.Web3Provider(window.ethereum);
        } catch (err) {
            addError("Erro ao conectar com o provider: " + err.message);
            return;
        }
    }
    
    try {
        // Verificar se existe código no endereço
        const code = await provider.getCode(contractAddress);
        
        if (code === '0x') {
            addError("❌ PROBLEMA: Não existe contrato neste endereço!");
            addError("O endereço pode estar incorreto ou o contrato não foi deployed.");
        } else {
            addError("✅ Contrato encontrado no endereço.");
            
            // Verificar se tem saldo (pode receber BNB)
            const balance = await provider.getBalance(contractAddress);
            addError(`Saldo do contrato: ${ethers.utils.formatEther(balance)} BNB`);
            
            // Tentar estimar gas para uma transação pequena
            try {
                const testGas = await provider.estimateGas({
                    to: contractAddress,
                    value: ethers.utils.parseEther("0.001") // 0.001 BNB de teste
                });
                addError("✅ Contrato aceita transações BNB.");
            } catch (gasErr) {
                addError("❌ PROBLEMA: Contrato rejeita transações BNB.");
                addError("Motivo: " + gasErr.message);
            }
        }
    } catch (err) {
        addError("Erro ao verificar contrato: " + err.message);
    }
}

// Funções para manipular lista de erros
function addError(msg) {
    const ul = document.getElementById("errorList");
    const li = document.createElement("li");
    li.textContent = msg;
    ul.appendChild(li);
}
function clearErrors() {
    document.getElementById("errorList").innerHTML = "";
}

// Eventos dos botões
document.getElementById("checkContract").addEventListener("click", checkContract);
document.getElementById("buyButton").addEventListener("click", async () => {
    clearErrors();
    try {
        if (!signer) await connectWallet();
        await buyTokens();
    } catch (err) {
        addError("Erro inesperado: " + err.message);
    }
});
</script>
</body>
</html>
