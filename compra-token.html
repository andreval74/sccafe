<!DOCTYPE html>
<html lang="pt-BR" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Compra de Tokens - SCCAFE</title>
  
  <!-- Favicons -->
  <link rel="icon" type="image/png" sizes="16x16" href="imgs/sccafe-16x16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="imgs/sccafe-32x32.png">
  <link rel="icon" type="image/png" sizes="192x192" href="imgs/sccafe-192x192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="imgs/sccafe-512x512.png">
  
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
  
  <!-- SCCAFE Global CSS Unificado -->
  <link href="styles/globals.css" rel="stylesheet">
  
  <!-- Meta tags SEO -->
  <meta name="description" content="Compre tokens diretamente via MetaMask com os melhores preços do mercado. Suporte para Ethereum, BSC, Polygon e outras redes.">
  <meta name="keywords" content="comprar token, metamask, pancakeswap, uniswap, DEX, swap, SCCAFE">
</head>
<body>
  <!-- Header -->
  <header data-component="header"></header>
  
  <!-- Main Content -->
  <main class="token-purchase-main py-5">
    <div class="container">
      <div class="row justify-content-center">
        <div class="col-xl-8 col-lg-10">
          <!-- Page Header -->
          <div class="text-center mb-5">
            <h1 class="display-5 fw-bold text-white mb-3">
              <i class="bi bi-cart-check text-primary me-3"></i>Compra de Tokens
            </h1>
            <p class="lead text-secondary">
              Compre tokens diretamente via MetaMask com os melhores preços das principais DEXs
            </p>
          </div>
          
          <!-- Purchase Card -->
          <div class="card bg-dark border-primary shadow-lg">
            <!-- Connection Status -->
            <div class="card-header bg-primary text-dark">
              <div class="d-flex justify-content-between align-items-center">
                <h5 class="mb-0">
                  <i class="bi bi-wallet2 me-2"></i>Status da Conexão
                </h5>
                <button id="connectBtn" class="btn btn-dark btn-sm">
                  <i class="bi bi-link-45deg me-1"></i>Conectar MetaMask
                </button>
              </div>
            </div>

            
            <div class="card-body p-4">
              <!-- Connection Status Display -->
              <div class="connection-status mb-4">
                <div class="alert alert-info d-flex align-items-center" id="connectionAlert">
                  <i class="bi bi-info-circle me-2"></i>
                  <span id="status">Detectando MetaMask...</span>
                </div>
                <div class="text-center">
                  <small class="text-muted">
                    Não tem MetaMask? 
                    <a href="https://metamask.io/" target="_blank" class="text-primary text-decoration-none fw-bold">
                      <i class="bi bi-download me-1"></i>Instalar aqui
                    </a>
                  </small>
                </div>
              </div>

              <!-- Purchase Form -->
              <form id="purchaseForm">
                <!-- Token Selection -->
                <div class="row g-4 mb-4">
                  <div class="col-md-8">
                    <label for="tokenAddress" class="form-label text-white">
                      <i class="bi bi-coin text-primary me-2"></i>Endereço do Token (ERC-20/BEP-20)
                    </label>
                    <input type="text" class="form-control bg-dark text-white border-secondary" 
                           id="tokenAddress" placeholder="0x..." required>
                    <div class="form-text text-muted">Endereço do contrato do token que deseja comprar</div>
                  </div>
                  <div class="col-md-4">
                    <label for="network" class="form-label text-white">
                      <i class="bi bi-globe text-primary me-2"></i>Rede/DEX
                    </label>
                    <select class="form-control bg-dark text-white border-secondary" id="network">
                      <option value="1">Ethereum (Uniswap)</option>
                      <option value="56" selected>BSC (PancakeSwap)</option>
                      <option value="137">Polygon (QuickSwap)</option>
                      <option value="43114">Avalanche (Trader Joe)</option>
                    </select>
                  </div>
                </div>

                <!-- Receiver Address -->
                <div class="mb-4">
                  <label for="receiverAddress" class="form-label text-white">
                    <i class="bi bi-person-badge text-primary me-2"></i>Endereço Recebedor
                  </label>
                  <input type="text" class="form-control bg-dark text-white border-secondary" 
                         id="receiverAddress" placeholder="0x..." required>
                  <div class="form-text text-muted">Endereço que receberá os tokens comprados (deixe vazio para usar sua carteira)</div>
                </div>

                <!-- Purchase Details -->
                <div class="row g-4 mb-4">
                  <div class="col-md-6">
                    <label for="ethAmount" class="form-label text-white">
                      <i class="bi bi-currency-exchange text-primary me-2"></i>Valor em ETH/BNB/MATIC
                    </label>
                    <input type="number" class="form-control bg-dark text-white border-secondary" 
                           id="ethAmount" placeholder="0.1" step="0.001" min="0.001" required>
                    <div class="form-text text-muted">Quantidade de moeda nativa que deseja trocar</div>
                  </div>
                  <div class="col-md-6">
                    <label for="expectedTokens" class="form-label text-white">
                      <i class="bi bi-graph-up text-primary me-2"></i>Tokens Estimados
                    </label>
                    <input type="text" class="form-control bg-dark text-white border-secondary" 
                           id="expectedTokens" placeholder="Calculando..." readonly>
                    <div class="form-text text-muted">Quantidade estimada de tokens que receberá</div>
                  </div>
                </div>

                <!-- Advanced Settings -->
                <div class="card bg-secondary mb-4">
                  <div class="card-header">
                    <h6 class="mb-0 text-white">
                      <i class="bi bi-gear text-primary me-2"></i>Configurações Avançadas
                    </h6>
                  </div>
                  <div class="card-body">
                    <div class="row g-3">
                      <div class="col-md-6">
                        <label for="slippage" class="form-label text-white">Slippage (%)</label>
                        <select class="form-control bg-dark text-white border-secondary" id="slippage">
                          <option value="0.5">0.5% (Baixo)</option>
                          <option value="1" selected>1% (Padrão)</option>
                          <option value="2">2% (Médio)</option>
                          <option value="5">5% (Alto)</option>
                          <option value="custom">Personalizado</option>
                        </select>
                      </div>
                      <div class="col-md-6">
                        <label for="deadline" class="form-label text-white">Deadline (minutos)</label>
                        <input type="number" class="form-control bg-dark text-white border-secondary" 
                               id="deadline" value="20" min="1" max="60">
                      </div>
                    </div>
                    <div class="row g-3 mt-2" id="customSlippageRow" style="display: none;">
                      <div class="col-md-6">
                        <label for="customSlippage" class="form-label text-white">Slippage Personalizado (%)</label>
                        <input type="number" class="form-control bg-dark text-white border-secondary" 
                               id="customSlippage" placeholder="3.5" step="0.1" min="0.1" max="50">
                      </div>
                    </div>
                  </div>
                </div>

                <!-- Action Buttons -->
                <div class="d-grid gap-2">
                  <button type="button" id="calculateBtn" class="btn btn-outline-primary btn-lg" disabled>
                    <i class="bi bi-calculator me-2"></i>Calcular Preço
                  </button>
                  <button type="submit" id="executeBtn" class="btn btn-primary btn-lg" disabled>
                    <i class="bi bi-cart-check me-2"></i>Executar Compra
                  </button>
                </div>
              </form>
            </div>
          </div>

          <!-- Transaction Log -->
          <div class="card bg-dark border-secondary mt-4">
            <div class="card-header">
              <h5 class="mb-0 text-white">
                <i class="bi bi-journal-text text-primary me-2"></i>Log de Transações
              </h5>
            </div>
            <div class="card-body">
              <pre id="log" class="bg-black text-light p-3 rounded" style="max-height: 300px; overflow-y: auto;">Aguardando ação do usuário...</pre>
            </div>
          </div>

          <!-- Help Section -->
          <div class="card bg-secondary mt-4">
            <div class="card-body">
              <h6 class="text-white mb-3">
                <i class="bi bi-info-circle text-primary me-2"></i>Como Funciona
              </h6>
              <div class="row g-3">
                <div class="col-md-4">
                  <div class="text-center">
                    <i class="bi bi-wallet2 text-primary" style="font-size: 2rem;"></i>
                    <h6 class="text-white mt-2">1. Conecte</h6>
                    <small class="text-muted">Conecte sua MetaMask à rede desejada</small>
                  </div>
                </div>
                <div class="col-md-4">
                  <div class="text-center">
                    <i class="bi bi-calculator text-primary" style="font-size: 2rem;"></i>
                    <h6 class="text-white mt-2">2. Calcule</h6>
                    <small class="text-muted">Veja o preço atual e quantidade estimada</small>
                  </div>
                </div>
                <div class="col-md-4">
                  <div class="text-center">
                    <i class="bi bi-arrow-left-right text-primary" style="font-size: 2rem;"></i>
                    <h6 class="text-white mt-2">3. Troque</h6>
                    <small class="text-muted">Execute o swap via DEX com melhor preço</small>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Footer -->
  <footer data-component="footer"></footer>

  <!-- Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  
  <!-- Template Loader -->
  <script src="js/template-loader.js"></script>

  <script>
    /**
     * SCCAFE Token Purchase System
     * Suporte para múltiplas DEXs: PancakeSwap, Uniswap, QuickSwap, Trader Joe
     */

    // Configurações das DEXs por rede
    const DEX_CONFIG = {
      1: { // Ethereum
        name: 'Ethereum (Uniswap)',
        router: '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D',
        weth: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
        dexName: 'Uniswap V2',
        nativeCoin: 'ETH',
        blockExplorer: 'https://etherscan.io'
      },
      56: { // BSC
        name: 'BSC (PancakeSwap)',
        router: '0x10ED43C718714eb63d5aA57B78B54704E256024E',
        weth: '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // WBNB
        dexName: 'PancakeSwap V2',
        nativeCoin: 'BNB',
        blockExplorer: 'https://bscscan.com'
      },
      137: { // Polygon
        name: 'Polygon (QuickSwap)',
        router: '0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff',
        weth: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270', // WMATIC
        dexName: 'QuickSwap',
        nativeCoin: 'MATIC',
        blockExplorer: 'https://polygonscan.com'
      },
      43114: { // Avalanche
        name: 'Avalanche (Trader Joe)',
        router: '0x60aE616a2155Ee3d9A68541Ba4544862310933d4',
        weth: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', // WAVAX
        dexName: 'Trader Joe',
        nativeCoin: 'AVAX',
        blockExplorer: 'https://snowtrace.io'
      }
    };

    // Estado global
    let provider = null;
    let signer = null;
    let userAddress = null;
    let currentChainId = null;
    let currentConfig = null;

    // Elementos da UI
    const ui = {
      status: document.getElementById('status'),
      connectBtn: document.getElementById('connectBtn'),
      calculateBtn: document.getElementById('calculateBtn'),
      executeBtn: document.getElementById('executeBtn'),
      connectionAlert: document.getElementById('connectionAlert'),
      
      tokenAddress: document.getElementById('tokenAddress'),
      receiverAddress: document.getElementById('receiverAddress'),
      ethAmount: document.getElementById('ethAmount'),
      expectedTokens: document.getElementById('expectedTokens'),
      network: document.getElementById('network'),
      slippage: document.getElementById('slippage'),
      customSlippage: document.getElementById('customSlippage'),
      deadline: document.getElementById('deadline'),
      
      log: document.getElementById('log')
    };

    // Funções utilitárias
    function log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const icon = type === 'error' ? '❌' : type === 'success' ? '✅' : 'ℹ️';
      ui.log.textContent = `[${timestamp}] ${icon} ${message}\n` + ui.log.textContent;
      console.log(`[SCCAFE Purchase] ${message}`);
    }

    function shortAddr(addr) {
      if (!addr) return '';
      return addr.slice(0, 6) + '...' + addr.slice(-4);
    }

    function updateConnectionStatus(connected, chainId = null) {
      if (connected && userAddress) {
        const config = DEX_CONFIG[chainId] || { name: `Chain ${chainId}`, nativeCoin: 'ETH' };
        ui.status.textContent = `Conectado: ${shortAddr(userAddress)} - ${config.name}`;
        ui.connectBtn.innerHTML = '<i class="bi bi-check-circle me-1"></i>Conectado';
        ui.connectBtn.className = 'btn btn-success btn-sm';
        ui.connectionAlert.className = 'alert alert-success d-flex align-items-center';
        
        ui.calculateBtn.disabled = false;
        currentConfig = config;
        
        // Auto-preencher endereço recebedor se vazio
        if (!ui.receiverAddress.value) {
          ui.receiverAddress.value = userAddress;
        }
        
        log(`Conectado com sucesso à ${config.name}`, 'success');
      } else {
        ui.status.textContent = 'MetaMask não conectado';
        ui.connectBtn.innerHTML = '<i class="bi bi-link-45deg me-1"></i>Conectar MetaMask';
        ui.connectBtn.className = 'btn btn-dark btn-sm';
        ui.connectionAlert.className = 'alert alert-warning d-flex align-items-center';
        
        ui.calculateBtn.disabled = true;
        ui.executeBtn.disabled = true;
        currentConfig = null;
      }
    }

    // Detectar provider
    function detectProvider() {
      if (typeof window.ethereum === 'undefined') {
        ui.status.textContent = 'MetaMask não detectado';
        ui.connectionAlert.className = 'alert alert-danger d-flex align-items-center';
        ui.connectBtn.disabled = true;
        log('MetaMask não encontrado. Instale MetaMask para continuar.', 'error');
        return false;
      }
      
      provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
      log('MetaMask detectado com sucesso');
      return true;
    }

    // Conectar carteira
    async function connectWallet() {
      if (!window.ethereum) {
        alert('MetaMask não encontrado. Instale MetaMask para continuar.');
        return;
      }

      try {
        log('Solicitando conexão com MetaMask...');
        
        const accounts = await window.ethereum.request({ 
          method: 'eth_requestAccounts' 
        });
        
        if (!accounts || accounts.length === 0) {
          log('Nenhuma conta retornada pelo MetaMask', 'error');
          return;
        }

        provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
        signer = provider.getSigner();
        userAddress = accounts[0];

        const network = await provider.getNetwork();
        currentChainId = network.chainId;

        updateConnectionStatus(true, currentChainId);
        
        // Atualizar select de rede
        ui.network.value = currentChainId.toString();
        
      } catch (error) {
        if (error.code === 4001) {
          log('Conexão rejeitada pelo usuário', 'error');
        } else {
          log(`Erro ao conectar: ${error.message}`, 'error');
        }
        updateConnectionStatus(false);
      }
    }

    // Calcular preço
    async function calculatePrice() {
      if (!provider || !currentConfig) {
        alert('Conecte sua carteira primeiro');
        return;
      }

      const tokenAddr = ui.tokenAddress.value.trim();
      const ethAmount = ui.ethAmount.value;

      if (!tokenAddr || !ethAmount) {
        alert('Preencha o endereço do token e valor em ETH');
        return;
      }

      try {
        log('Calculando preço...');
        ui.expectedTokens.value = 'Calculando...';

        // Router ABI para getAmountsOut
        const routerAbi = [
          'function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts)'
        ];

        const router = new ethers.Contract(currentConfig.router, routerAbi, provider);
        const amountIn = ethers.utils.parseEther(ethAmount);
        const path = [currentConfig.weth, tokenAddr];

        const amounts = await router.getAmountsOut(amountIn, path);
        const tokensOut = amounts[1];

        // Obter decimais do token
        const tokenAbi = ['function decimals() view returns (uint8)'];
        const tokenContract = new ethers.Contract(tokenAddr, tokenAbi, provider);
        let decimals = 18;
        
        try {
          decimals = await tokenContract.decimals();
        } catch (e) {
          log('Assumindo 18 decimais para o token', 'info');
        }

        const formattedTokens = ethers.utils.formatUnits(tokensOut, decimals);
        ui.expectedTokens.value = parseFloat(formattedTokens).toFixed(6);
        
        ui.executeBtn.disabled = false;
        
        log(`Preço calculado: ${ethAmount} ${currentConfig.nativeCoin} = ${parseFloat(formattedTokens).toFixed(6)} tokens`, 'success');
        
      } catch (error) {
        log(`Erro ao calcular preço: ${error.message}`, 'error');
        ui.expectedTokens.value = 'Erro no cálculo';
        ui.executeBtn.disabled = true;
      }
    }

    // Executar compra
    async function executePurchase() {
      if (!provider || !signer || !currentConfig) {
        alert('Conecte sua carteira primeiro');
        return;
      }

      const tokenAddr = ui.tokenAddress.value.trim();
      const receiverAddr = ui.receiverAddress.value.trim();
      const ethAmount = ui.ethAmount.value;
      
      if (!tokenAddr || !receiverAddr || !ethAmount) {
        alert('Preencha todos os campos obrigatórios');
        return;
      }

      try {
        log('Preparando transação de compra...');

        // Calcular slippage
        let slippagePercent = parseFloat(ui.slippage.value);
        if (ui.slippage.value === 'custom') {
          slippagePercent = parseFloat(ui.customSlippage.value);
        }
        
        const slippageFactor = (100 - slippagePercent) / 100;
        
        // Obter amounts out novamente
        const routerAbi = [
          'function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts)',
          'function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts)'
        ];

        const router = new ethers.Contract(currentConfig.router, routerAbi, signer);
        const amountIn = ethers.utils.parseEther(ethAmount);
        const path = [currentConfig.weth, tokenAddr];

        const amounts = await router.getAmountsOut(amountIn, path);
        const expectedOut = amounts[1];
        const minAmountOut = expectedOut.mul(Math.floor(slippageFactor * 1000)).div(1000);

        const deadline = Math.floor(Date.now() / 1000) + (parseInt(ui.deadline.value) * 60);

        log(`Executando swap: ${ethAmount} ${currentConfig.nativeCoin} → tokens via ${currentConfig.dexName}`);
        log(`Slippage: ${slippagePercent}% | Deadline: ${ui.deadline.value} min`);

        const tx = await router.swapExactETHForTokens(
          minAmountOut,
          path,
          receiverAddr,
          deadline,
          { value: amountIn }
        );

        log(`Transação enviada: ${tx.hash}`, 'success');
        log(`Aguardando confirmação...`);

        const receipt = await tx.wait();
        
        log(`✅ Compra realizada com sucesso!`, 'success');
        log(`Hash: ${tx.hash}`);
        log(`Explorador: ${currentConfig.blockExplorer}/tx/${tx.hash}`);
        
        // Reset form
        ui.ethAmount.value = '';
        ui.expectedTokens.value = '';
        ui.executeBtn.disabled = true;

      } catch (error) {
        if (error.code === 4001) {
          log('Transação rejeitada pelo usuário', 'error');
        } else {
          log(`Erro na compra: ${error.message}`, 'error');
        }
      }
    }

    // Event listeners
    ui.connectBtn.addEventListener('click', connectWallet);
    ui.calculateBtn.addEventListener('click', calculatePrice);
    ui.executeBtn.addEventListener('click', executePurchase);
    
    // Auto-calcular quando mudar valores
    ui.ethAmount.addEventListener('input', () => {
      if (ui.ethAmount.value && ui.tokenAddress.value) {
        ui.expectedTokens.value = 'Digite calcular para atualizar';
        ui.executeBtn.disabled = true;
      }
    });

    ui.tokenAddress.addEventListener('input', () => {
      ui.expectedTokens.value = '';
      ui.executeBtn.disabled = true;
    });

    // Slippage personalizado
    ui.slippage.addEventListener('change', () => {
      const customRow = document.getElementById('customSlippageRow');
      if (ui.slippage.value === 'custom') {
        customRow.style.display = 'block';
      } else {
        customRow.style.display = 'none';
      }
    });

    // Mudança de rede
    ui.network.addEventListener('change', () => {
      const selectedChain = parseInt(ui.network.value);
      if (currentChainId !== selectedChain) {
        log(`Mudança de rede necessária: ${DEX_CONFIG[selectedChain]?.name}`);
        // Aqui poderia solicitar mudança de rede via MetaMask
      }
    });

    // Listeners para mudanças da carteira
    function setupWalletListeners() {
      if (!window.ethereum) return;

      window.ethereum.on('accountsChanged', (accounts) => {
        if (!accounts || accounts.length === 0) {
          log('Carteira desconectada');
          userAddress = null;
          updateConnectionStatus(false);
        } else {
          userAddress = accounts[0];
          updateConnectionStatus(true, currentChainId);
          log(`Conta alterada: ${shortAddr(userAddress)}`);
        }
      });

      window.ethereum.on('chainChanged', (chainIdHex) => {
        const chainId = parseInt(chainIdHex, 16);
        currentChainId = chainId;
        currentConfig = DEX_CONFIG[chainId];
        updateConnectionStatus(true, chainId);
        ui.network.value = chainId.toString();
        log(`Rede alterada: ${currentConfig?.name || `Chain ${chainId}`}`);
        
        // Reset cálculos
        ui.expectedTokens.value = '';
        ui.executeBtn.disabled = true;
      });
    }

    // Inicialização
    document.addEventListener('DOMContentLoaded', async function() {
      log('🚀 SCCAFE Token Purchase iniciado');
      
      if (detectProvider()) {
        setupWalletListeners();
        
        // Verificar se já está conectado
        try {
          const accounts = await provider.listAccounts();
          if (accounts && accounts.length > 0) {
            signer = provider.getSigner();
            userAddress = accounts[0];
            const network = await provider.getNetwork();
            currentChainId = network.chainId;
            updateConnectionStatus(true, currentChainId);
            ui.network.value = currentChainId.toString();
          } else {
            updateConnectionStatus(false);
          }
        } catch (error) {
          log('Erro ao verificar conexão existente', 'error');
          updateConnectionStatus(false);
        }
      }
    });

  </script>
</body>
</html>